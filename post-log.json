{
  "session_id": "a2a05f2b-9a7d-4686-9da0-1e33f6927206",
  "transcript_path": "/Users/recardo/.claude/projects/-Users-recardo-ai-queries/a2a05f2b-9a7d-4686-9da0-1e33f6927206.jsonl",
  "cwd": "/Users/recardo/ai/queries",
  "hook_event_name": "PostToolUse",
  "tool_name": "Read",
  "tool_input": {
    "file_path": "/Users/recardo/ai/queries/src/queries/order_queries.ts"
  },
  "tool_response": {
    "type": "text",
    "file": {
      "filePath": "/Users/recardo/ai/queries/src/queries/order_queries.ts",
      "content": "import { Database } from \"sqlite\";\n\ninterface OrderItem {\n  order_item_id: number;\n  product_id: number;\n  product_name: string;\n  quantity: number;\n  price_at_time: number;\n}\n\ninterface OrderDetails {\n  order_id: number;\n  order_date: string;\n  status: string;\n  total_amount: number;\n  customer_email: string;\n  shipping_address: string;\n  shipping_city: string;\n  shipping_state: string;\n  shipping_zip: string;\n  items: OrderItem[];\n}\n\nexport async function getOrderDetails(\n  db: Database,\n  orderId: number\n): Promise<OrderDetails | null> {\n  const query = `\n    SELECT \n        o.order_id,\n        o.order_date,\n        o.status,\n        o.total_amount,\n        c.email as customer_email,\n        o.shipping_address,\n        o.shipping_city,\n        o.shipping_state,\n        o.shipping_zip,\n        oi.order_item_id,\n        oi.product_id,\n        p.name as product_name,\n        oi.quantity,\n        oi.price_at_time\n    FROM orders o\n    JOIN customers c ON o.customer_id = c.customer_id\n    JOIN order_items oi ON o.order_id = oi.order_id\n    JOIN products p ON oi.product_id = p.product_id\n    WHERE o.order_id = ?\n    `;\n\n  const rows: any[] = await db.all(query, [orderId]);\n\n  if (!rows || rows.length === 0) {\n    return null;\n  }\n\n  const order: OrderDetails = {\n    order_id: rows[0].order_id,\n    order_date: rows[0].order_date,\n    status: rows[0].status,\n    total_amount: rows[0].total_amount,\n    customer_email: rows[0].customer_email,\n    shipping_address: rows[0].shipping_address,\n    shipping_city: rows[0].shipping_city,\n    shipping_state: rows[0].shipping_state,\n    shipping_zip: rows[0].shipping_zip,\n    items: [],\n  };\n\n  for (const row of rows) {\n    order.items.push({\n      order_item_id: row.order_item_id,\n      product_id: row.product_id,\n      product_name: row.product_name,\n      quantity: row.quantity,\n      price_at_time: row.price_at_time,\n    });\n  }\n\n  return order;\n}\n\nexport async function fetchCustomerOrders(\n  db: Database,\n  customerId: number,\n  limit: number = 10\n): Promise<any[]> {\n  const query = `\n    SELECT \n        o.order_id,\n        o.order_date,\n        o.status,\n        o.total_amount,\n        o.shipping_city,\n        o.shipping_state,\n        COUNT(oi.order_item_id) as item_count\n    FROM orders o\n    LEFT JOIN order_items oi ON o.order_id = oi.order_id\n    WHERE o.customer_id = ?\n    GROUP BY o.order_id, o.order_date, o.status, o.total_amount, \n             o.shipping_city, o.shipping_state\n    ORDER BY o.order_date DESC\n    LIMIT ?\n    `;\n\n  const rows = await db.all(query, [customerId, limit]);\n  return rows;\n}\n\nexport async function getPendingOrders(db: Database): Promise<any[]> {\n  const query = `\n    SELECT \n        o.order_id,\n        o.order_date,\n        o.total_amount,\n        c.first_name || ' ' || c.last_name as customer_name,\n        c.phone,\n        julianday('now') - julianday(o.order_date) as days_since_created\n    FROM orders o\n    JOIN customers c ON o.customer_id = c.customer_id\n    WHERE o.status = 'pending'\n    ORDER BY o.order_date\n    `;\n\n  const rows = await db.all(query, []);\n  return rows;\n}\n\nexport async function findOrdersByStatus(\n  db: Database,\n  status: string\n): Promise<any[]> {\n  const query = `\n    SELECT DISTINCT\n        o.order_id,\n        o.order_date,\n        o.total_amount,\n        c.email as customer_email,\n        GROUP_CONCAT(DISTINCT p.sku) as product_skus,\n        GROUP_CONCAT(DISTINCT w.name) as warehouses\n    FROM orders o\n    JOIN customers c ON o.customer_id = c.customer_id\n    LEFT JOIN order_items oi ON o.order_id = oi.order_id\n    LEFT JOIN products p ON oi.product_id = p.product_id\n    LEFT JOIN inventory i ON p.product_id = i.product_id\n    LEFT JOIN warehouses w ON i.warehouse_id = w.warehouse_id\n    WHERE o.status = ?\n    GROUP BY o.order_id, o.order_date, o.total_amount, c.email\n    ORDER BY o.order_date DESC\n    `;\n\n  const rows = await db.all(query, [status]);\n  return rows;\n}\n\nexport async function getRecentOrders(\n  db: Database,\n  days: number = 7\n): Promise<any[]> {\n  const query = `\n    SELECT DISTINCT\n        o.order_id,\n        o.order_date,\n        o.total_amount,\n        o.shipping_amount,\n        c.segment as customer_segment,\n        CASE \n            WHEN o.shipping_amount = 0 THEN 'Free Shipping'\n            WHEN o.shipping_amount < 10 THEN 'Standard'\n            WHEN o.shipping_amount < 25 THEN 'Express'\n            ELSE 'Priority'\n        END as shipping_method,\n        GROUP_CONCAT(DISTINCT cat.name) as product_categories\n    FROM orders o\n    JOIN customers c ON o.customer_id = c.customer_id\n    LEFT JOIN order_items oi ON o.order_id = oi.order_id\n    LEFT JOIN products p ON oi.product_id = p.product_id\n    LEFT JOIN categories cat ON p.category_id = cat.category_id\n    WHERE o.order_date >= date('now', '-' || ? || ' days')\n    GROUP BY o.order_id, o.order_date, o.total_amount, o.shipping_amount, c.segment\n    ORDER BY o.order_date DESC\n    `;\n\n  const rows = await db.all(query, [days]);\n  return rows;\n}\n\nexport async function fetchOrdersByDateRange(\n  db: Database,\n  startDate: string,\n  endDate: string\n): Promise<any[]> {\n  const query = `\n    SELECT \n        o.order_id,\n        o.order_date,\n        o.total_amount,\n        c.status as customer_status,\n        o.billing_state,\n        COUNT(oi.order_item_id) as item_count\n    FROM orders o\n    JOIN customers c ON o.customer_id = c.customer_id\n    LEFT JOIN order_items oi ON o.order_id = oi.order_id\n    WHERE o.order_date >= ? AND o.order_date <= ?\n    GROUP BY o.order_id, o.order_date, o.total_amount, c.status, o.billing_state\n    ORDER BY o.order_date DESC\n    `;\n\n  const rows = await db.all(query, [startDate, endDate]);\n  return rows;\n}\n\nexport async function getHighValueOrders(\n  db: Database,\n  minAmount: number = 500\n): Promise<any[]> {\n  const query = `\n    WITH customer_ltv AS (\n        SELECT \n            customer_id,\n            SUM(total_amount) as lifetime_value\n        FROM orders\n        GROUP BY customer_id\n    )\n    SELECT DISTINCT\n        o.order_id,\n        o.order_date,\n        o.total_amount,\n        c.email,\n        ltv.lifetime_value as customer_lifetime_value,\n        o.shipping_address,\n        o.shipping_city,\n        o.shipping_state,\n        o.shipping_zip,\n        GROUP_CONCAT(p.name) as product_names\n    FROM orders o\n    JOIN customers c ON o.customer_id = c.customer_id\n    JOIN customer_ltv ltv ON c.customer_id = ltv.customer_id\n    LEFT JOIN order_items oi ON o.order_id = oi.order_id\n    LEFT JOIN products p ON oi.product_id = p.product_id\n    WHERE o.total_amount >= ?\n    GROUP BY o.order_id, o.order_date, o.total_amount, c.email, \n             ltv.lifetime_value, o.shipping_address, o.shipping_city, \n             o.shipping_state, o.shipping_zip\n    ORDER BY o.total_amount DESC\n    `;\n\n  const rows = await db.all(query, [minAmount]);\n  return rows;\n}\n",
      "numLines": 251,
      "startLine": 1,
      "totalLines": 251
    }
  }
}
